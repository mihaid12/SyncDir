
/*
* SPDX-FileCopyrightText: Copyright Â© 2022 Mihai-Ioan Popescu <mihai.popescu.d12@gmail.com>
*
* SPDX-License-Identifier: Apache-2.0
*/


#include "syncdir_clt_file_info_proc.h"



//
// DeleteAllFileInfosForDir
//
SDSTATUS
DeleteAllFileInfosForDir(
    __in char *DirRelativePath,
    __inout std::unordered_map<std::string, FILE_INFO> & FileInfoHMap
    )
/*++
Description: The routine deletes from FileInfoHMap all the FILE_INFO structures of the files inside the directory DirRelativePath, but
excluding the FileInfo of the DirRelativePath itself (i.e. whose relative paths match exactly).

- DirRelativePath: Pointer to the relative path of the directory.
- FileInfoHMap: Reference to the hash map containing the FILE_INFO structures generated by file events.

Return value: STATUS_SUCCESS upon success, STATUS_FAIL otherwise.
--*/
{
    SDSTATUS status;

    // PREINIT.

    status = STATUS_FAIL;

    // Parameter validation.

    if (NULL == DirRelativePath || 0 == DirRelativePath[0])
    {
        printf("[SyncDir] Error: DeleteAllFileInfosForDir(): Invalid paramter 1.\n");
        return STATUS_FAIL;
    }


    __try
    {
        // INIT.
        // --


        // Main processing:

        // Delete all FileInfo's beyond the path of the directory (DirRelativePath), but not the FileInfo of the directory itself.
        // Don't auto increment the iterator, since the deletion returns an iterator on the next position in the hash map.
        //
        // Note: to avoid the FileInfo of DirRelativePath, we make sure the path does not stop exactly at DirRelativePath length,
        //      so that it points inside the DirRelativePath directory.
        
        for (auto it = FileInfoHMap.begin(); it != FileInfoHMap.end(); )
        {   
            if (0 == strncmp(DirRelativePath, it->second.RelativePath, strlen(DirRelativePath)) &&
                0 != it->second.RelativePath[strlen(DirRelativePath)] )                 // Excluding directory's own FileInfo.
            {
                it = FileInfoHMap.erase(it);
            }
            else
            {
                it++;
            }
        }


        // If here, everything is ok.
        status = STATUS_SUCCESS;

    } // --> __try
    __catch (const SyncDirException &e)
    {
        cout << e.what() << "\n";        
        //status = STATUS_FAIL;
    }
    __catch (const std::exception &e)
    {
        cout << "[SyncDir] Error: DeleteAllFileInfosForDir(): Standard Exception caught: " << e.what() << "\n";        
        status = STATUS_FAIL;
    }
    __catch (...)
    {
        printf("[SyncDir] Error: DeleteAllFileInfosForDir(): Unkown exception.\n");
        status = STATUS_FAIL;
    }


    // UNINIT. Cleanup.
    if (SUCCESS(status))
    {
        // Nothing to clean for the moment.
    }
    else
    {
        // Nothing to clean for the moment.
    }

    return status;
} // DeleteAllFileInfosForDir()




//
// InitFileInfo
//
SDSTATUS
InitFileInfo(
    __out FILE_INFO *FileInfo
    )
/*++
Description: The routine initializes with neutral (default) values all the fields of a FILE_INFO structure.

- FileInfo: Pointer to the structure containing the file information to be initialized.

Return value: STATUS_SUCCESS on success, STATUS_FAIL otherwise.
--*/
{
    SDSTATUS status;

    // PREINIT.
    status = STATUS_FAIL;

    // Parameter validation.
    if (NULL == FileInfo)
    {
        printf("[SyncDir] Error: InitFileInfo(): Invalid parameter 1.\n");
        return STATUS_FAIL;
    }

    // Init
    // --

    // Main processing:

    FileInfo->FileType = ftUNKNOWN;
    FileInfo->FileExistedBeforeEvents = TRUE;   // Assuming TRUE avoids any unwanted event loss.

    FileInfo->OldWatchNodeOfParent = NULL;      // For the main directory ("root dir") it stays NULL.
    FileInfo->FileName[0] = 0;              

    FileInfo->RelativePath[0] = 0;
    FileInfo->RealRelativePath[0] = 0;
    FileInfo->MD5Hash[0] = 0;               
    FileInfo->Inode = 0;
    FileInfo->FileSize = 0;

    FileInfo->WasCreated = FALSE;
    FileInfo->WasDeleted = FALSE;
    FileInfo->WasModified = FALSE;

    FileInfo->WasMovedFromOnly = FALSE;
    FileInfo->WasMovedToOnly = FALSE;
    FileInfo->WasMovedFromAndTo = FALSE;
    FileInfo->MovementCookie = 0;               // No cookie / Guard value, for file movement.

    FileInfo->OldWatchNodeOfParent = NULL;
    FileInfo->OldRelativePath[0] = 0;
    FileInfo->OldFileName[0] = 0;


    // If here, everything worked well.
    status = STATUS_SUCCESS;

    // UNINIT. Cleanup.
    //cleanup_InitFileInfo:

    if (SUCCESS(status))
    {
        // Nothing to clean for the moment.
    }
    else
    {
        // Nothing to clean for the moment.
    }

    return status;
} // InitFileInfo




//
// InsertNewFileInfo
//
SDSTATUS
InsertNewFileInfo(
    __in PFILE_INFO NewFileInfo,
    __inout std::unordered_map<std::string, FILE_INFO> &FileInfoHMap
    )
/*++
Description: The routine inserts in the hash map FileInfoHMap the file information pointed by NewFileInfo. The key of the NewFileInfo in
the hash map is represented by the RelativePath field (NewFileInfo->RelativePath).

- NewFileInfo: Pointer to the file information structure.
- FileInfoHMap: Reference to the hash map containing the FILE_INFO structures.

Return value: STATUS_SUCCESS on success, STATUS_FAIL otherwise.
--*/
{
    SDSTATUS status;
    std::string auxString;

    // PREINIT.

    status = STATUS_FAIL;
 
    // Parameter validation.

    if (NULL == NewFileInfo)
    {
        printf("[SyncDir] Error: InsertNewFileInfo(): invalid parameter 1.\n");
        return STATUS_FAIL;
    }


    __try
    {
        // INIT.
        // --

        // Main processing:

        // Insert a new FileInfo in the hash map (key == relative path).

        auxString.assign(NewFileInfo->RelativePath);                                    // Transform to std::string.

        auto inserted = FileInfoHMap.insert({auxString, (*NewFileInfo)});
        if (false == inserted.second)
        {
            perror("[SyncDir] Error: InsertNewFileInfo(): Unsuccessful insertion of new FileInfo in the hash map.\n");
            throw SyncDirException();
        }

        fprintf(g_SD_STDLOG, "Inserted new FileInfo structure: \n");
        fprintf(g_SD_STDLOG, "- FileType: [%d] \n", NewFileInfo->FileType);
        fprintf(g_SD_STDLOG, "- File path: [%s] \n", NewFileInfo->RelativePath);



        // If here, everything is ok.
        status = STATUS_SUCCESS;

    } // --> __try
    __catch (const SyncDirException &e)
    {
        cout << e.what() << "\n";        
        //status = STATUS_FAIL;
    }
    __catch (const std::exception &e)
    {
        cout << "[SyncDir] Error: InsertNewFileInfo(): Standard Exception caught: " << e.what() << "\n";        
        status = STATUS_FAIL;
    }
    __catch (...)
    {
        printf("[SyncDir] Error: InsertNewFileInfo(): Unkown exception.\n");
        status = STATUS_FAIL;
    }


    // UNINIT. Cleanup.
    if (SUCCESS(status))
    {
        // Nothing to clean for the moment.
    }
    else
    {
        // Nothing to clean for the moment.
    }

    return status;
} // InsertNewFileInfo()



//
// SetMovementCookiesForDirMovedFrom
//
SDSTATUS
SetMovementCookiesForDirMovedFrom(
    __in DWORD  DirCookie,
    __in char   *DirRelativePath,
    __inout std::unordered_map<std::string, FILE_INFO> & FileInfoHMap
    )
/*++
Description: The routine sets a "move indicator / cookie" value for all the FileInfo's that contain a given path. Concretely, the routine
sets the DirCookie value for the FILE_INFO.MovementCookie field of all the FileInfo's whose relative path contain the directory DirRelativePath.
The FileInfo's are contained by the hash map FileInfoHMap. This routine is required in case a whole directory was part of a MOVED_FROM/MOVE 
operation.

- DirCookie: Integer representing the movement cookie value that indicates the move operation.
- DirRelativePath: Pointer to the relative path of the directory.
- FileInfoHMap: Reference of the hash map containing the FILE_INFO's of the file events. 

Return value: STATUS_SUCCESS, upon success, STATUS_FAIL otherwise.

Note: A 0 (zero) value for the movement cookie of an inotify_event structure (inotify_event.cookie field) is considered to not be used 
by the kernel API of Inotify in practice (even though the documentation does not state anything in this sense). Hence, we consider "0"
to be an unused value for the inotify_event.cookie field, and therefore we use it as guard value throughout the SyncDir application.
--*/
{
    SDSTATUS status;
    FILE_INFO *fileInfoMovement;

    // PREINIT.

    status = STATUS_FAIL;
    fileInfoMovement = NULL;    

    // Parameter validation.

    if (0 == DirCookie)
    {
        printf("[SyncDir] Error: SetMovementCookiesForDirMovedFrom(): Invalid parameter 2.\n");
        return STATUS_FAIL;
    }    
    if (NULL == DirRelativePath || 0 == DirRelativePath[0])
    {
        printf("[SyncDir] Error: SetMovementCookiesForDirMovedFrom(): Invalid parameter 2.\n");
        return STATUS_FAIL;
    }


    __try
    {
        // INIT.
        // --

        // Main processing:

        // Mark with cookie all the FileInfo's related to DirRelativePath.

        for (auto &element: FileInfoHMap)
        {
            fileInfoMovement = &(element.second);   
            if (0 == strncmp(DirRelativePath, fileInfoMovement->RelativePath, strlen(DirRelativePath)))
            {
                if (0 == fileInfoMovement->MovementCookie && FALSE == fileInfoMovement->WasMovedFromOnly)      // Assuming the "guard" value (0).
                {
                    fileInfoMovement->MovementCookie = DirCookie;
                }
                // If 0 != cookie, it means that the file is already part of a "move" operation.
            } 
        }


        // If here, everything is ok.
        status = STATUS_SUCCESS;

    } // --> __try
    __catch (const SyncDirException &e)
    {
        cout << e.what() << "\n";        
        //status = STATUS_FAIL;
    }
    __catch (const std::exception &e)
    {
        cout << "[SyncDir] Error: SetMovementCookiesForDirMovedFrom(): Standard Exception caught: " << e.what() << "\n";        
        status = STATUS_FAIL;
    }
    __catch (...)
    {
        printf("[SyncDir] Error: SetMovementCookiesForDirMovedFrom(): Unkown exception.\n");
        status = STATUS_FAIL;
    }


    // UNINIT. Cleanup.
    if (SUCCESS(status))
    {
        // Nothing to clean for the moment.
    }
    else
    {
        // Nothing to clean for the moment.
    }

    return status;
} // SetMovementCookiesForDirMovedFrom()



//
// FindFileInfoByMovementCookie
//
SDSTATUS
FindFileInfoByMovementCookie(
    __in DWORD          CookieToFind,
    __out PFILE_INFO    *FileInfoFound,
    __in std::unordered_map<std::string, FILE_INFO> & FileInfoHMap    
    )
/*++
Description: The routine searches for a FileInfo whose MovementCookie field equals a given value. Concretely, the routine finds the FILE_INFO
structure inside the FileInfoHMap hash map which has the movement cookie equal to CookieToFind. The result is stored at FileInfoFound.

- CookieToFind: Integer (movement cookie) identifying a move operation of a file.
- FileInfoFound: Pointer to where the address of the resulted FileInfo is stored, if one is found by the routine, or NULL otherwise.
    The caller provides the storage space.
- FileInfoHMap: Reference to the hash map containing the FILE_INFO structures generated by file events.

Return value: STATUS_SUCCESS on success, STATUS_FAIL otherwise.
--*/
{
    SDSTATUS status;
    FILE_INFO *FileInfoWithCookie;

    // PREINIT.

    status = STATUS_FAIL;
    FileInfoWithCookie = NULL;

    // Parameter validation.

    if (0 == CookieToFind)
    {
        printf("[SyncDir] Error: FindFileInfoByMovementCookie(): Invalid paramter 1. \n");
        return STATUS_FAIL;
    }
    if (NULL == FileInfoFound)
    {
        printf("[SyncDir[ Error: FindFileInfoByMovementCookie(): Invalid paramter 2.\n");
        return STATUS_FAIL;
    }


    __try
    {
        // INIT.
        
        FileInfoWithCookie = NULL;


        // Main processing:

        // Find cookie match among the FileInfo's.
        
        for (auto &element: FileInfoHMap)
        {
            if (CookieToFind == element.second.MovementCookie && TRUE == element.second.WasMovedFromOnly)
            {
                FileInfoWithCookie = &(element.second);
                break;
            }
        }

        // Output results.

        if (NULL == FileInfoWithCookie)
        {
            (*FileInfoFound) = NULL;
        }
        else
        {
            (*FileInfoFound) = FileInfoWithCookie;
        }


        // If here, everything is ok.
        status = STATUS_SUCCESS;

    } // --> __try
    __catch (const SyncDirException &e)
    {
        cout << e.what() << "\n";        
        //status = STATUS_FAIL;
    }
    __catch (const std::exception &e)
    {
        cout << "[SyncDir] Error: FindFileInfoByMovementCookie(): Standard Exception caught: " << e.what() << "\n";        
        status = STATUS_FAIL;
    }
    __catch (...)
    {
        printf("[SyncDir] Error: FindFileInfoByMovementCookie(): Unkown exception.\n");
        status = STATUS_FAIL;
    }


    // UNINIT. Cleanup.
    if (SUCCESS(status))
    {
        // Nothing to clean for the moment.
    }
    else
    {
        // Nothing to clean for the moment.
    }

    return status;
} // FindFileInfoByMovementCookie()



//
// UpdateFileInfoPath
//
SDSTATUS
UpdateFileInfoPath(
    __inout FILE_INFO       *FileInfoToUpdate,
    __in PDIR_WATCH_NODE    NewWatchNodeOfParent,
    __in char               *NewFileName,
    __in char               *NewFileRelativePath,
    __inout DIR_WATCH       *Watches,
    __inout DWORD           *NumberOfWatches,
    __in __int32            HInotify,
    __inout std::unordered_map<std::string, FILE_INFO> & FileInfoHMap
    )
/*++
Description: The routine updates the path fields of a given FileInfo, also performing necessary modifications related to the path update.
Concretely, the routine updates the FileInfoToUpdate structure with new values: NewWatchNodeOfParent, NewFileName, NewFileRealtivePath. 
The old values are stored in the same FileInfo structure. The path update may generate additional necessary modifications, for which 
Watches, NumberOfWatches, HInotify and FileInfoHMap are needed.

- FileInfoToUpdate: Pointer to the FileInfo whose path fields are updated by the routine.
- NewWatchNodeOfParent: Pointer to the address of the watch node representing the new parent directory of the file 
- NewFileName: Pointer to the string containing the new file name. 
- NewFileRelativePath: Pointer to the string containing the new relative path of the file.
- Watches: Pointer to the array of directory watches.
- NumberOfWatches: Pointer to the size of the Watches array.
- HInotify: Descriptor of the Inotify instance containing the Inotify watches of the monitored directories.
- FileInfoHMap: Reference to the hash map of FILE_INFO structures generated by file events.

Return value: STATUS_SUCCESS on success, STATUS_FAIL otherwise. STATUS_WARNING could be returned if the main purpose of the routine
was achieved, but related issues were encountered (information is logged, thereby).
--*/
{
    SDSTATUS        status;
    EVENT_DATA      oldEventData;
    std::string     auxString;
    
    // PREINIT.

    status = STATUS_FAIL;

    // Parameter validation

    if (NULL == FileInfoToUpdate)
    {
        printf("[SyncDir] Error: UpdateFileInfoPath(): Invalid parameter 1.\n");
        return STATUS_FAIL;
    }
    if (NULL == NewWatchNodeOfParent)
    {
        printf("[SyncDir] Error: UpdateFileInfoPath(): Invalid parameter 2.\n");
        return STATUS_FAIL;
    }
    if (NULL == NewFileName || 0 == NewFileName[0])
    {
        printf("[SyncDir] Error: UpdateFileInfoPath(): Invalid parameter 3.\n");
        return STATUS_FAIL;
    }
    if (NULL == NewFileRelativePath || 0 == NewFileRelativePath[0])
    {
        printf("[SyncDir] Error: UpdateFileInfoPath(): Invalid parameter 4.\n");
        return STATUS_FAIL;
    }
    if (NULL == Watches)
    {
        printf("[SyncDir] Error: UpdateFileInfoPath(): Invalid parameter 5.\n");
        return STATUS_FAIL;
    }
    if (NULL == NumberOfWatches || gWatchesArrayCapacity < (*NumberOfWatches))
    {
        printf("[SyncDir] Error: UpdateFileInfoPath(): Invalid parameter 6.\n");
        return STATUS_FAIL;
    }
    if ( HInotify < 0 )
    {
        printf("[SyncDir] Error: UpdateFileInfoPath(): Invalid parameter 7.\n");
        return STATUS_FAIL;
    }
    if (FileInfoHMap.size() <= 0)
    {
        printf("[SyncDir] Error: UpdateFileInfoPath(): Invalid parameter 8.\n");
        return STATUS_FAIL;
    }

    // Avoid repeated calls.
    if (0 == FileInfoToUpdate->MovementCookie)
    {
        printf("[SyncDir] Warning: UpdateFileInfoPath(): Not suitable for path change (movement cookie is 0). \n");
        return STATUS_WARNING;
    }


    __try
    {
        // INIT.
        // --


        //
        // Start main processing:
        //


        // If there is a previous MOVE in the FileInfo.
        // ==> Delete the destination file of the previous MOVE.
        // Note: opDELETE cannot generate a resize of the Watches array. So the Watches pointer does not modify in the current routine, 
        // even if ProcessOperationAndAggregate can resize Watches under different parameters.

        if (0 != strlen(FileInfoToUpdate->OldRelativePath))              
        {
            oldEventData.OperationType = opDELETE;
            strcpy(oldEventData.RelativePath, FileInfoToUpdate->OldRelativePath);
            snprintf(oldEventData.FullPath, SD_MAX_PATH_LENGTH, "%s/%s", 
                Watches[FileInfoToUpdate->OldWatchNodeOfParent->DirWatchIndex].DirFullPath, FileInfoToUpdate->OldFileName);
            strcpy(oldEventData.FileName, FileInfoToUpdate->OldFileName);
            oldEventData.WatchIndex = FileInfoToUpdate->OldWatchNodeOfParent->DirWatchIndex;
            oldEventData.Cookie = 0;
            oldEventData.IsDirectory = (ftDIRECTORY == FileInfoToUpdate->FileType ? TRUE : FALSE);
            oldEventData.FileExistedBeforeEvents = TRUE;

            status = ProcessOperationAndAggregate(opDELETE, NULL, &oldEventData, &Watches, NumberOfWatches, HInotify, FileInfoHMap);
            if (!(SUCCESS(status)))
            {
                printf("[SyncDir] Error: UpdateFileInfoPath(): Failed to execute ProcessOperationAndAggregate().\n");
                status = STATUS_FAIL;
                throw SyncDirException();
            }
        }


        // Store old location info.
        // (for detecting future possible deletions; see the deletion above)

        FileInfoToUpdate->OldWatchNodeOfParent = FileInfoToUpdate->WatchNodeOfParent;
        strcpy(FileInfoToUpdate->OldFileName, FileInfoToUpdate->FileName);
        strcpy(FileInfoToUpdate->OldRelativePath, FileInfoToUpdate->RelativePath);


        // Update path values.

        FileInfoToUpdate->WatchNodeOfParent = NewWatchNodeOfParent;
        strcpy(FileInfoToUpdate->FileName, NewFileName);
        strcpy(FileInfoToUpdate->RelativePath, NewFileRelativePath);


        // Reset movement cookie.

        FileInfoToUpdate->MovementCookie = 0;


        // Insert new hash entry. 
        // Erase old hash entry.
        // - For forced insertion, use: FileInfoHMap[FileInfoToUpdate->RelativePath] = (*FileInfoToUpdate);                

        if (0 != strcmp(FileInfoToUpdate->RelativePath, FileInfoToUpdate->OldRelativePath))
        {
            auxString.assign(FileInfoToUpdate->RelativePath);                           // Transform to std::string.

            auto pair = FileInfoHMap.insert({auxString, (*FileInfoToUpdate)});          // insertion.
            if (FALSE == pair.second)
            {
                printf("[SyncDir] Error: UpdateFileInfoPath(): Failed to insert the updated FileInfo in the hash map.\n");
                status = STATUS_FAIL;
                throw SyncDirException();
            }

            auxString.assign(FileInfoToUpdate->OldRelativePath);                        // Transform to std::string.

            if (1 != FileInfoHMap.erase(auxString))                                     // erasure.
            {
                printf("[SyncDir] Warning: UpdateFileInfoPath(): Failed to erase the FileInfo from the hash map.\n");
                status = STATUS_WARNING;
            }
        }


        // If here, everything is ok.
        status = SUCCESS_KEEP_WARNING(status);

    } // --> __try
    __catch (const SyncDirException &e)
    {
        cout << e.what() << "\n";        
        //status = STATUS_FAIL;
    }
    __catch (const std::exception &e)
    {
        cout << "[SyncDir] Error: UpdateFileInfoPath(): Standard Exception caught: " << e.what() << "\n";        
        status = STATUS_FAIL;
    }
    __catch (...)
    {
        printf("[SyncDir] Error: UpdateFileInfoPath(): Unkown exception.\n");
        status = STATUS_FAIL;
    }


    // UNINIT. Cleanup.
    if (SUCCESS(status))
    {
        // Nothing to clean for the moment.
    }
    else
    {
        // Nothing to clean for the moment.
    }

    return status;
} // UpdateFileInfoPath()




